---
description: 'Update : 2025.08.07'
---

# 8. EKS 활용 사례 2 (배포)

## 0. 사전 설정

Deployment에 대한 활용사례를 실습하기 위해, Sample Application을 사전 배포합니다.

```
cd ~/environment/
#Sample Application 을 Clone 하고, 실행합니다.
git clone https://github.com/aws-samples/eks-workshop-v2.git
kubectl apply -k ~/environment/eks-workshop-v2/manifests/base-application

```

Sample Application이 정상적으로 동작하는 지 확인합니다.

```
kubectl get namespaces -l app.kubernetes.io/created-by=eks-workshop
kubectl get deployment -l app.kubernetes.io/created-by=eks-workshop -A

```

&#x20;30\~40초 후에 아래와 같은 결과를 확인할 수 있습니다.

```
$ kubectl get deployment -l app.kubernetes.io/created-by=eks-workshop -A
NAMESPACE   NAME             READY   UP-TO-DATE   AVAILABLE   AGE
carts       carts            1/1     1            1           36s
carts       carts-dynamodb   1/1     1            1           36s
catalog     catalog          1/1     1            1           36s
checkout    checkout         1/1     1            1           36s
checkout    checkout-redis   1/1     1            1           36s
orders      orders           1/1     1            1           36s
ui          ui               1/1     1            1           36s
```

## 1. EKS 관리를 위한 Cusotm Agent와 Context 설정

### 1.1 Custom Agent 설정

EKS 관리를 위한 별도의 Custom Agent를 설정해 봅니다.

```
/agent create -n eksadmin
```

실행 후 제공되는 vi editor 창에 아래와 같은 eks agent용 JSON 파일을 입력합니다.

```
{
  "name": "eksadmin",
  "description": "EKS 관리자를 위한 agent 입니다.",
  "prompt": null,
  "mcpServers": {
    "awslabs.eks-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.eks-mcp-server@latest",
        "--allow-write",
        "--allow-sensitive-data-access"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "autoApprove": [],
      "disabled": false
    },
    "aws-knowledge-mcp-server": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://knowledge-mcp.global.api.aws"
      ],
      "autoApprove": [],
      "disabled": false
    },
    "awslabs.core-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.core-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "autoApprove": [],
      "disabled": false
    },
    "awslabs.aws-documentation-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.aws-documentation-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR",
        "AWS_DOCUMENTATION_PARTITION": "aws"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.cdk-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.cdk-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.aws-diagram-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.aws-diagram-mcp-server"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "autoApprove": [],
      "disabled": false
    },
    "awslabs.cfn-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.cfn-mcp-server@latest"
      ],
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.cloudwatch-mcp-server": {
      "autoApprove": [],
      "disabled": false,
      "command": "uvx",
      "args": [
        "awslabs.cloudwatch-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "transportType": "stdio"
    },
    "awslabs.cost-explorer-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.cost-explorer-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.aws-api-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.aws-api-mcp-server@latest"
      ],
      "env": {
        "AWS_REGION": "us-east-1"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.terraform-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.terraform-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.code-doc-gen-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.code-doc-gen-mcp-server@latest"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    },
    "awslabs.iam-mcp-server": {
      "command": "uvx",
      "args": [
        "awslabs.iam-mcp-server@latest"
      ],
      "env": {
        "AWS_REGION": "us-east-1",
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    }
  },
  "tools": ["*"],
  "toolAliases": {},
  "allowedTools": ["fsRead"],
  "resources": ["file://~/.amazonq/rules/eksadmin/eksadmin.md"],
  "hooks": {},
  "toolsSettings": {},
  "useLegacyMcpJson": true
}

```

### 1.2 컨텍스트 파일 생성 (eksadmin.md)

q chat 창에서 빠져나와서 , shell 모드로 변경합니다.

```
/quit
```

아래와 같이 eksadmin agent를 위한 context를 추가합니다.

```
mkdir ~/.amazonq/rules/eksadmin
cat > ~/.amazonq/rules/eksadmin/eksadmin.md << 'EOF'
당신은 EKS 관리자 입니다.
기본 리전은 ap-northeast-2 입니다.
EKS Cluster 의 이름은 "eksworkshop" 입니다.
기술적 용어는 한글과 영어를 동시 표기합니다.
모든 결과는 markdown으로 ~/output에 파일로 작성합니다.
사용자가 “application” 또는 “app”이라고 언급할 경우, 이는 ~/environment/eks-workshop-v2/manifests/base-application 경로에 위치한 애플리케이션을 의미합니다.
애플리케이션에 대한 모든 변경 사항은 업데이트를 적용하기 전에 YAML 파일에서 수정되어야 합니다.
업데이트를 적용할 때는 애플리케이션의 최상위 디렉터리에서 kustomize 플래그 -f 를 사용해야 합니다.
애플리케이션 토폴로지 다이어그램을 생성할 때는 Markdown(.md) 파일로 작성하며, 아래와 같은 MkDocs용 mermaid 코드 스니펫을 포함해야 합니다:
\`\`\`mermaid
graph LR
A[Start] --> B{Error?};
B -->|Yes| C[Hmm...];
C --> D[Debug];
D --> B;
B ---->|No| E[Yay!];
\`\`\`
EOF
```

이 파일은 다음과 같은 행동 규칙을 Amazon Q에게 전달합니다:

* eks 관리자 역할을 명시
* region (ap-northeast-2), eks cluster name (eksworkshop)을 명시
* 모든 결과를 한글로 출력하고, 기술용어를 한글과 영어로 동시 표기 명시
* 결과는 markdown으로 저장할 것을 명시
* “application”은 `~/environment/eks-workshop-v2/manifests/base-application` 경로의 앱을 의미함
* 업데이트 전 YAML 파일을 수정해야 함
* kustomize 플래그 `-f` 를 루트 디렉터리에 사용
* 다이어그램은 `.md` 파일로, `Mermaid` 형식으로 작성

### 1.3. Custom Agent 세션 시작

eks custom agent로 실행합니다.

```
q chat --agent eksadmin
```

아래와 같은 실행 창을 확인 할 수 있습니다.

```
$ q chat --agent eksadmin
WARNING: MCP server 'awslabs.eks-mcp-server' is already configured in agent config. Skipping duplicate from legacy mcp.json.
✓ awslabs.aws-diagram-mcp-server loaded in 1.23 s
✓ playwright loaded in 2.47 s
✓ awslabs.aws-documentation-mcp-server loaded in 2.56 s
✓ awslabs.core-mcp-server loaded in 3.00 s
✓ awslabs.cdk-mcp-server loaded in 3.20 s
✓ awslabs.code-doc-gen-mcp-server loaded in 3.25 s
✓ awslabs.cfn-mcp-server loaded in 3.60 s
✓ awslabs.cloudwatch-mcp-server loaded in 3.68 s
✓ awslabs.terraform-mcp-server loaded in 3.69 s
✓ awslabs.iam-mcp-server loaded in 3.78 s
✓ awslabs.eks-mcp-server loaded in 3.87 s
✓ awslabs.aws-api-mcp-server loaded in 4.46 s
✓ awslabs.cost-explorer-mcp-server loaded in 4.51 s
✓ aws-knowledge-mcp-server loaded in 4.56 s


    ⢠⣶⣶⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣶⣦⡀⠀
 ⠀⠀⠀⣾⡿⢻⣿⡆⠀⠀⠀⢀⣄⡄⢀⣠⣤⣤⡀⢀⣠⣤⣤⡀⠀⠀⢀⣠⣤⣤⣤⣄⠀⠀⢀⣤⣤⣤⣤⣤⣤⡀⠀⠀⣀⣤⣤⣤⣀⠀⠀⠀⢠⣤⡀⣀⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⢠⣿⣿⠋⠀⠀⠀⠙⣿⣿⡆
 ⠀⠀⣼⣿⠇⠀⣿⣿⡄⠀⠀⢸⣿⣿⠛⠉⠻⣿⣿⠛⠉⠛⣿⣿⠀⠀⠘⠛⠉⠉⠻⣿⣧⠀⠈⠛⠛⠛⣻⣿⡿⠀⢀⣾⣿⠛⠉⠻⣿⣷⡀⠀⢸⣿⡟⠛⠉⢻⣿⣷⠀⠀⠀⠀⠀⠀⣼⣿⡏⠀⠀⠀⠀⠀⢸⣿⣿
 ⠀⢰⣿⣿⣤⣤⣼⣿⣷⠀⠀⢸⣿⣿⠀⠀⠀⣿⣿⠀⠀⠀⣿⣿⠀⠀⢀⣴⣶⣶⣶⣿⣿⠀⠀⠀⣠⣾⡿⠋⠀⠀⢸⣿⣿⠀⠀⠀⣿⣿⡇⠀⢸⣿⡇⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⢹⣿⣇⠀⠀⠀⠀⠀⢸⣿⡿
 ⢀⣿⣿⠋⠉⠉⠉⢻⣿⣇⠀⢸⣿⣿⠀⠀⠀⣿⣿⠀⠀⠀⣿⣿⠀⠀⣿⣿⡀⠀⣠⣿⣿⠀⢀⣴⣿⣋⣀⣀⣀⡀⠘⣿⣿⣄⣀⣠⣿⣿⠃⠀⢸⣿⡇⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣦⣀⣀⣀⣴⣿⡿⠃
 ⠚⠛⠋⠀⠀⠀⠀⠘⠛⠛⠀⠘⠛⠛⠀⠀⠀⠛⠛⠀⠀⠀⠛⠛⠀⠀⠙⠻⠿⠟⠋⠛⠛⠀⠘⠛⠛⠛⠛⠛⠛⠃⠀⠈⠛⠿⠿⠿⠛⠁⠀⠀⠘⠛⠃⠀⠀⠘⠛⠛⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠿⢿⣿⣿⣋⠀⠀
 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⡧

╭─────────────────────────────── Did you know? ────────────────────────────────╮
│                                                                              │
│      You can execute bash commands by typing ! followed by the command       │
│                                                                              │
╰──────────────────────────────────────────────────────────────────────────────╯

/help all commands  •  ctrl + j new lines  •  ctrl + s fuzzy search
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🤖 You are chatting with claude-4-sonnet

[eksadmin] > 
```

### 1.5 현재 적용된 컨텍스트 확인

```
/context show
```

실행 결과는 아래와 같습니다:

```
[eksadmin] > /context show


👤 Agent (eksadmin):
    ~/.amazonq/rules/eksadmin/eksadmin.md (1 match)

No files in the current directory matched the rules above.
```

💡 출력 결과에 eksadmin.md가 포함되어 있으면 컨텍스트 설정이 정상적으로 완료된 것입니다.

***

## 2. 애플리케이션 검토 (Review Application)

### 2.1 어플리케이션 리뷰 (Review Application)

프롬프트:

```
~/environment/eks-workshop-v2/manifests/base-application 어플리케이션을 설명해줘.
```

설명:

* 지정된 경로에 있는 애플리케이션이 어떤 구성으로 되어 있는지, 어떤 마이크로서비스로 나뉘는지에 대해 요약 설명을 요청합니다.

실행 결과는 아래와 같습니다:

```
> ~/environment/eks-workshop-v2/manifests/base-application 애플리케이션에 대한 상세한 분석을 완료했습니다.

## 주요 분석 결과 요약

이 애플리케이션은 마이크로서비스 아키텍처 기반의 온라인 소매점 샘플 애플리케이션으로, 다음과 같은 특징을 가지고 있습니다:

### 🏗️ 아키텍처 구성
• **6개의 마이크로서비스**: UI, Catalog, Carts, Checkout, Orders, Other
• **독립적인 네임스페이스**: 각 서비스별로 격리된 네임스페이스 사용
• **다양한 데이터베이스**: MySQL, DynamoDB, Redis, PostgreSQL 활용

### 🔧 기술 스택
• **컨테이너 이미지**: AWS ECR Public에서 제공하는 샘플 이미지 사용
• **주요 언어**: Java (Spring Boot) 기반
• **배포 도구**: Kustomize를 사용한 선언적 구성 관리

### 🛡️ 보안 및 모니터링
• **보안 강화**: Non-root 사용자, 읽기 전용 파일시스템, 최소 권한 적용
• **모니터링 준비**: Prometheus 메트릭 수집 및 헬스 체크 구성

### 📊 서비스 토폴로지
UI 서비스가 프론트엔드 역할을 하며, 나머지 서비스들과 HTTP 통신을 통해 각각의 비즈니스 로직을 처리합니다.

상세한 분석 결과는 ~/output/base-application-analysis.md 파일에 저장되었습니다. 이 파일에는 각 서비스의 구성, 데이터베이스 연결, 통신 방식, 그리고 애플리케이션 토폴로지 다이어그램이 포함되어 있습니다.
```

[makrdown 예시 ](https://www.notion.so/whchoi98/base-application-analysis-24804ef7e60e806d9ef8e555537eac29?source=copy_link)

### 2.2 애플리케이션 배포 (Deploy Application)

프롬프트:

```
~/environment/eks-workshop-v2/manifests/base-application 에 있는 Application을 배포해줘.
kustomize option in kubectl 의 kustomize option을 사용해줘.
```

설명:

* kubectl apply -k 명령을 사용하여 base-application을 클러스터에 배포합니다.
* Q CLI는 kustomize를 이용한 배포를 자동 실행합니다.

실행 결과는 아래와 같습니다:

```
## 🎉 배포 완료!

~/environment/eks-workshop-v2/manifests/base-application 애플리케이션이 kubectl의 kustomize 옵션 (-k)을 사용하여 성공적으로 배포되었습니다.

### 📊 배포 결과 요약

✅ 배포 성공 현황:
• **네임스페이스**: 6개 모두 Active 상태
• **Pod**: 9개 모두 Running 상태 
• **Service**: 9개 모두 정상 동작
• **데이터베이스**: MySQL, DynamoDB, Redis, PostgreSQL 모두 정상 실행

🔧 사용된 배포 명령어:
bash
kubectl apply -k ~/environment/eks-workshop-v2/manifests/base-application


📈 주요 서비스 현황:
• **UI Service**: ui-77d959f887-qx2nl (Running)
• **Catalog Service**: catalog-7f5cbc5d9-xh9bw (Running) + MySQL
• **Carts Service**: carts-5c55d4b6bb-cpnds (Running) + DynamoDB
• **Checkout Service**: checkout-54c6cd5685-wcjg9 (Running) + Redis  
• **Orders Service**: orders-5f4b646944-6gzl5 (Running) + PostgreSQL

📝 상세한 배포 결과는 ~/output/base-application-deployment.md 파일에 저장되었습니다.

이제 마이크로서비스 아키텍처 기반의 온라인 소매점 샘플 애플리케이션이 EKS 클러스터 "eksworkshop"에서 정상적으로 실행되고 있습니다!
```

[makrdown 예시 ](https://www.notion.so/whchoi98/base-application-deployment-24804ef7e60e80a6aab0cfefe14eeb51?source=copy_link)

***

### 2.3 애플리케이션 준비 상태 확인 (Application Readiness)

프롬프트:

```
애플리케이션에 속한 모든 파드가 준비(Ready) 상태가 될 때까지 기다립니다.
```

설명:

* 배포된 파드들이 모두 Ready 상태가 될 때까지 기다립니다. Q CLI가 상태를 추적해 알려줍니다.

실행 결과는 아래와 같습니다:

```
## ✅ 모든 파드가 Ready 상태 완료!

애플리케이션에 속한 모든 파드가 성공적으로 준비(Ready) 상태가 되었습니다.

### 🎯 Ready 상태 확인 결과

✅ 완료된 네임스페이스:
• **UI**: 1개 파드 Ready
• **Catalog**: 2개 파드 Ready (catalog + MySQL)
• **Carts**: 2개 파드 Ready (carts + DynamoDB)
• **Checkout**: 2개 파드 Ready (checkout + Redis)
• **Orders**: 2개 파드 Ready (orders + PostgreSQL)

### 📊 최종 상태 요약

| 지표 | 결과 |
|------|------|
| 총 파드 수 | 9개 |
| Ready 상태 | 9개 (100%) |
| Running 상태 | 9개 (100%) |
| 타임아웃 내 완료 | ✅ 300초 내 |
| 네트워크 분산 | ✅ 9개 워커 노드에 분산 |

### 🔍 사용된 명령어

각 네임스페이스별로 다음 명령어를 실행하여 Ready 상태를 확인했습니다:

bash
kubectl wait --for=condition=Ready pod --all -n [namespace] --timeout=300s


### 📝 상세 결과

상세한 Ready 상태 확인 결과는 ~/output/pods-ready-status.md 파일에 저장되었습니다.

이제 EKS Workshop Base Application의 모든 마이크로서비스가 완전히 준비되어 서비스 간 통신과 사용자 요청을 처리할 수 있는 상태입니다! 🚀
```

[makrdown 예시 ](https://www.notion.so/whchoi98/pods-ready-status-24804ef7e60e807ca2f4c15f69a9151c?source=copy_link)

### 2.4 애플리케이션 업데이트 (Update the Application)

프롬프트:

```
checkout 디플로이먼트를 3개의 레플리카로 업데이트하세요.
적용하기 전에 반드시 YAML 파일을 먼저 수정해야 합니다.
```

설명:

* checkout 디플로이먼트의 복제 수(replicas)를 3으로 변경합니다.
* YAML 파일 수정 → 적용(kustomize) 순으로 진행됩니다.

실행 결과는 아래와 같습니다:

```
## ✅ Checkout 디플로이먼트 레플리카 업데이트 완료!

checkout 디플로이먼트를 1개에서 3개 레플리카로 성공적으로 확장했습니다.

### 🔧 수행된 작업 순서

1. YAML 파일 수정: /home/ec2-user/environment/eks-workshop-v2/manifests/base-application/checkout/deployment.yaml에서 replicas: 1 → replicas: 3으로 변경

2. Kustomize 적용: 애플리케이션 최상위 디렉터리에서 kubectl apply -k 명령어 사용

3. Ready 상태 확인: 모든 파드가 Ready 상태가 될 때까지 대기

### 📊 최종 결과

✅ 디플로이먼트 상태:
• **Ready**: 3/3 파드
• **Up-to-date**: 3개 파드
• **Available**: 3개 파드

🚀 파드 현황:
• checkout-54c6cd5685-99qtd (새로 생성)
• checkout-54c6cd5685-pdhf7 (새로 생성)  
• checkout-54c6cd5685-wcjg9 (기존 파드)
• checkout-redis-7fb554999b-rrs4q (Redis 파드)

### 🌐 주요 이점

• **고가용성**: 단일 장애점 제거
• **로드 분산**: 3개 파드로 트래픽 분산 처리
• **노드 분산**: 3개의 서로 다른 워커 노드에 배치
• **무중단 업데이트**: 롤링 업데이트로 서비스 중단 없음

📝 상세한 업데이트 결과는 ~/output/checkout-deployment-scale-update.md 파일에 저장되었습니다.

이제 checkout 서비스가 3배의 처리 용량과 향상된 가용성을 제공할 수 있습니다! 🎉
```

[makrdown 예시 ](https://www.notion.so/whchoi98/checkout-deployment-scale-update-24804ef7e60e8049bb81f14a48cb3f68?source=copy_link)

***

## 3. 토폴로지 시각화 (Topology Diagram)

프롬프트:

```
클러스터에서 실행 중인 애플리케이션의 토폴로지 다이어그램을 생성해 주세요.
```

설명:

현재 클러스터에 실행 중인 애플리케이션의 서비스 간 구조를 mermaid 기반 다이어그램으로 생성합니다.

MkDocs 또는 GitBook에서 시각화 가능한 Markdown 코드로 출력됩니다.

```
> ## 🎨 EKS 클러스터 애플리케이션 토폴로지 다이어그램 생성 완료!

클러스터에서 실행 중인 애플리케이션의 상세한 토폴로지 다이어그램을 생성했습니다.

### 📊 현재 애플리케이션 구성 요약

🏗️ 마이크로서비스 아키텍처:
• **UI Service**: 1개 파드 (프론트엔드)
• **Catalog Service**: 2개 파드 (카탈로그 + MySQL)
• **Carts Service**: 2개 파드 (장바구니 + DynamoDB)
• **Checkout Service**: 4개 파드 (결제 3개 + Redis 1개) - 확장됨
• **Orders Service**: 2개 파드 (주문 + PostgreSQL)

🌐 네트워크 구성:
• 총 11개 파드가 5개 네임스페이스에서 실행
• **ClusterIP 서비스**를 통한 내부 통신
• **DNS 기반 서비스 디스커버리**

### 🎯 주요 다이어그램 특징

📈 시각화된 요소:
• **서비스 간 통신 플로우**: UI → 백엔드 서비스들
• **데이터베이스 연결**: 각 서비스별 전용 데이터베이스
• **확장된 Checkout 서비스**: 3개 레플리카 + 로드 밸런서
• **네임스페이스 격리**: 보안 및 리소스 관리
• **실시간 상태**: 모든 파드의 현재 Running 상태

🔄 데이터 플로우:
• 사용자 요청 → UI Service → 백엔드 API들
• Checkout Service의 로드 밸런싱
• 서비스 간 HTTP 통신 경로

### 📝 생성된 파일

~/output/application-topology-diagram.md 파일에 다음 내용이 포함되어 있습니다:

1. Mermaid 토폴로지 다이어그램: 전체 애플리케이션 구조
2. 시퀀스 다이어그램: 사용자 요청 플로우
3. 상세 서비스 분석: 각 마이크로서비스별 역할과 특징
4. 리소스 사용량 분석: CPU/메모리 요구사항
5. 보안 및 네트워킹: 클러스터 보안 구성
6. 모니터링 구성: Prometheus 메트릭 및 헬스 체크

🎉 EKS 클러스터의 완전한 애플리케이션 토폴로지가 시각화되었습니다!

이 다이어그램을 통해 마이크로서비스 간의 관계, 데이터 플로우, 그리고 확장된 Checkout 서비스의 고가용성 구성을 명확하게 파악할 수 있습니다.

```

[makrdown 예시 ](https://whchoi98.notion.site/application-topology-diagram-24804ef7e60e805988d6fa15990b890f?source=copy_link)

